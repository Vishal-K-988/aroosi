/**
 * Biometric Authentication Convex Functions
 * Handles biometric settings, device management, and audit logging
 */

import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { api } from "./_generated/api";

// Types for better type safety
const biometricSettingsType = v.object({
  enabled: v.boolean(),
  autoLogin: v.boolean(),
  requireBiometricForPayments: v.boolean(),
  requireBiometricForSensitiveActions: v.boolean(),
  fallbackToPin: v.boolean(),
  lockoutDuration: v.number(),
  maxFailedAttempts: v.number(),
});

const biometricDeviceType = v.object({
  deviceId: v.string(),
  deviceName: v.optional(v.string()),
  platform: v.union(v.literal("ios"), v.literal("android")),
});

/**
 * Get biometric settings for the current user
 */
export const getBiometricSettings = query({
  args: {},
  handler: async (ctx) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    return userWithProfile.profile.biometricSettings || {
      enabled: false,
      autoLogin: false,
      requireBiometricForPayments: true,
      requireBiometricForSensitiveActions: true,
      fallbackToPin: true,
      lockoutDuration: 5,
      maxFailedAttempts: 3,
    };
  },
});

/**
 * Update biometric settings for the current user
 */
export const updateBiometricSettings = mutation({
  args: {
    settings: biometricSettingsType,
  },
  handler: async (ctx, args) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    const now = Date.now();
    
    // If enabling biometric for the first time, set enabledAt timestamp
    const currentSettings = userWithProfile.profile.biometricSettings;
    const isEnabling = !currentSettings?.enabled && args.settings.enabled;

    const updatedSettings = {
      ...args.settings,
      enabledAt: isEnabling ? now : currentSettings?.enabledAt,
      lastUsed: currentSettings?.lastUsed,
    };

    await ctx.db.patch(userWithProfile.profile._id, {
      biometricSettings: updatedSettings,
      updatedAt: now,
    });

    // Log the settings change
    await logBiometricEvent(ctx, {
      action: "settings_change",
      result: "success",
      deviceId: "web",
      platform: "web",
      metadata: {
        changedSettings: Object.keys(args.settings),
      },
    });

    return updatedSettings;
  },
});

/**
 * Get registered biometric devices for the current user
 */
export const getBiometricDevices = query({
  args: {},
  handler: async (ctx) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    return userWithProfile.profile.biometricDevices || [];
  },
});

/**
 * Register a new biometric device
 */
export const registerBiometricDevice = mutation({
  args: biometricDeviceType,
  handler: async (ctx, args) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    const now = Date.now();
    const currentDevices = userWithProfile.profile.biometricDevices || [];
    
    // Check if device is already registered
    const existingDeviceIndex = currentDevices.findIndex(
      device => device.deviceId === args.deviceId
    );

    let updatedDevices;
    if (existingDeviceIndex >= 0) {
      // Update existing device
      updatedDevices = [...currentDevices];
      updatedDevices[existingDeviceIndex] = {
        ...updatedDevices[existingDeviceIndex],
        deviceName: args.deviceName,
        lastUsed: now,
        isActive: true,
      };
    } else {
      // Add new device
      const newDevice = {
        deviceId: args.deviceId,
        deviceName: args.deviceName,
        platform: args.platform,
        registeredAt: now,
        lastUsed: now,
        isActive: true,
      };
      updatedDevices = [...currentDevices, newDevice];
    }

    await ctx.db.patch(userWithProfile.profile._id, {
      biometricDevices: updatedDevices,
      updatedAt: now,
    });

    // Log the device registration
    await logBiometricEvent(ctx, {
      action: "device_registration",
      result: "success",
      deviceId: args.deviceId,
      platform: args.platform,
      metadata: {
        deviceName: args.deviceName,
        isNewDevice: existingDeviceIndex < 0,
      },
    });

    return updatedDevices;
  },
});

/**
 * Remove a biometric device
 */
export const removeBiometricDevice = mutation({
  args: {
    deviceId: v.string(),
  },
  handler: async (ctx, args) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    const currentDevices = userWithProfile.profile.biometricDevices || [];
    const updatedDevices = currentDevices.filter(
      device => device.deviceId !== args.deviceId
    );

    await ctx.db.patch(userWithProfile.profile._id, {
      biometricDevices: updatedDevices,
      updatedAt: Date.now(),
    });

    // Log the device removal
    await logBiometricEvent(ctx, {
      action: "device_removal",
      result: "success",
      deviceId: args.deviceId,
      platform: "web",
    });

    return updatedDevices;
  },
});

/**
 * Update device last used timestamp
 */
export const updateDeviceLastUsed = mutation({
  args: {
    deviceId: v.string(),
  },
  handler: async (ctx, args) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    const now = Date.now();
    const currentDevices = userWithProfile.profile.biometricDevices || [];
    
    const updatedDevices = currentDevices.map(device =>
      device.deviceId === args.deviceId
        ? { ...device, lastUsed: now }
        : device
    );

    await ctx.db.patch(userWithProfile.profile._id, {
      biometricDevices: updatedDevices,
      biometricSettings: {
        ...userWithProfile.profile.biometricSettings,
        lastUsed: now,
      },
      updatedAt: now,
    });

    return { success: true };
  },
});

/**
 * Log a biometric authentication event
 */
export const logBiometricEvent = mutation({
  args: {
    action: v.string(),
    result: v.string(),
    deviceId: v.string(),
    platform: v.optional(v.union(v.literal("ios"), v.literal("android"), v.literal("web"))),
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
    metadata: v.optional(v.object({
      errorMessage: v.optional(v.string()),
      attemptCount: v.optional(v.number()),
      biometricType: v.optional(v.string()),
      changedSettings: v.optional(v.array(v.string())),
      deviceName: v.optional(v.string()),
      isNewDevice: v.optional(v.boolean()),
    })),
  },
  handler: async (ctx, args) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile) {
      throw new Error("User not found");
    }

    await ctx.db.insert("biometricAuditLogs", {
      userId: userWithProfile.user._id,
      action: args.action,
      result: args.result,
      deviceId: args.deviceId,
      platform: args.platform,
      timestamp: Date.now(),
      ipAddress: args.ipAddress,
      userAgent: args.userAgent,
      metadata: args.metadata,
    });

    return { success: true };
  },
});

/**
 * Get biometric audit logs for the current user (Premium Plus feature)
 */
export const getBiometricAuditLogs = query({
  args: {
    limit: v.optional(v.number()),
    cursor: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    // Check if user has Premium Plus subscription
    if (userWithProfile.profile.subscriptionPlan !== "premiumPlus") {
      throw new Error("Biometric audit logs are only available for Premium Plus subscribers");
    }

    const limit = args.limit || 50;
    
    // Get audit logs for the user, ordered by timestamp (newest first)
    const logs = await ctx.db
      .query("biometricAuditLogs")
      .withIndex("by_userId_timestamp", (q) =>
        q.eq("userId", userWithProfile.user._id)
      )
      .order("desc")
      .take(limit);

    return logs;
  },
});

/**
 * Get biometric audit logs summary (for security dashboard)
 */
export const getBiometricAuditSummary = query({
  args: {
    days: v.optional(v.number()), // Number of days to look back
  },
  handler: async (ctx, args) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    // Check if user has Premium Plus subscription
    if (userWithProfile.profile.subscriptionPlan !== "premiumPlus") {
      throw new Error("Biometric audit summary is only available for Premium Plus subscribers");
    }

    const daysBack = args.days || 30;
    const cutoffTime = Date.now() - (daysBack * 24 * 60 * 60 * 1000);

    // Get recent audit logs
    const logs = await ctx.db
      .query("biometricAuditLogs")
      .withIndex("by_userId_timestamp", (q) =>
        q.eq("userId", userWithProfile.user._id)
      )
      .filter((q) => q.gte(q.field("timestamp"), cutoffTime))
      .collect();

    // Calculate summary statistics
    const totalEvents = logs.length;
    const successfulLogins = logs.filter(log => 
      log.action === "login" && log.result === "success"
    ).length;
    const failedAttempts = logs.filter(log => 
      log.result === "failure" || log.result === "biometric_error"
    ).length;
    const uniqueDevices = new Set(logs.map(log => log.deviceId)).size;
    const platforms = logs.reduce((acc, log) => {
      acc[log.platform || "unknown"] = (acc[log.platform || "unknown"] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return {
      period: daysBack,
      totalEvents,
      successfulLogins,
      failedAttempts,
      uniqueDevices,
      platforms,
      recentActivity: logs.slice(0, 10), // Last 10 events
    };
  },
});

/**
 * Check if biometric authentication is required for a specific action
 */
export const requiresBiometricAuth = query({
  args: {
    action: v.string(),
  },
  handler: async (ctx, args) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      return false;
    }

    const settings = userWithProfile.profile.biometricSettings;
    if (!settings?.enabled) {
      return false;
    }

    switch (args.action) {
      case "payment":
      case "subscription_purchase":
        return settings.requireBiometricForPayments;
      
      case "profile_update":
      case "settings_change":
      case "account_deletion":
      case "sensitive_data_access":
        return settings.requireBiometricForSensitiveActions;
      
      default:
        return false;
    }
  },
});

/**
 * Disable all biometric authentication (for account deletion)
 */
export const disableAllBiometricAuth = mutation({
  args: {},
  handler: async (ctx) => {
    const userWithProfile = await ctx.runQuery(api.users.getCurrentUserWithProfile, {});
    if (!userWithProfile || !userWithProfile.profile) {
      throw new Error("User profile not found");
    }

    // Clear all biometric data
    await ctx.db.patch(userWithProfile.profile._id, {
      biometricSettings: undefined,
      biometricDevices: undefined,
      updatedAt: Date.now(),
    });

    // Log the complete disable action
    await logBiometricEvent(ctx, {
      action: "complete_disable",
      result: "success",
      deviceId: "web",
      platform: "web",
      metadata: {
        reason: "account_cleanup",
      },
    });

    return { success: true };
  },
});